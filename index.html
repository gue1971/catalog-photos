<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Horse Board (V25: Sire Search Fix & Max Zoom)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --bg: #222;
    --card-bg: #111;
    --text-color: #eee;
    --accent: #0078ff;
    --zoom: 1.0;
    --gap: 2px;
  }

  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Yu Gothic", sans-serif;
    background: var(--bg);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation; 
  }

  .toolbar {
    position: fixed; bottom: 0; left: 0; right: 0;
    height: 54px;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
    gap: 32px;
    padding: 0 16px; z-index: 10000;
    border-top: 1px solid rgba(255,255,255,0.15);
  }
  
  .tool-btn {
    background: none; border: none;
    color: #888; display: flex; flex-direction: column; align-items: center;
    font-size: 10px; gap: 4px; cursor: pointer;
    width: 60px;
  }
  .tool-btn i { font-size: 20px; margin-bottom: 2px; }
  .tool-btn.active { color: var(--accent); }
  .tool-btn:active { transform: scale(0.95); }

  .viewport {
    width: 100vw;
    height: calc(100vh - 54px);
    overflow: auto; 
    position: relative;
    -webkit-overflow-scrolling: touch; 
    touch-action: manipulation;
  }

  .mode-indicator {
    position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
    background: rgba(0, 120, 255, 0.9); color: #fff;
    padding: 6px 16px; border-radius: 20px;
    font-size: 12px; font-weight: bold;
    z-index: 5000; pointer-events: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    display: none; 
  }

  .board {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: calc(var(--gap) * var(--zoom));
    width: calc(100% * var(--zoom));
    padding: 8px;
    box-sizing: border-box;
    padding-bottom: 300px; 
    transform-origin: 0 0;
  }

  .cell {
    position: relative;
    border-radius: calc(2px * var(--zoom));
    overflow: hidden;
    touch-action: manipulation;
    display: flex; flex-direction: column;
    box-sizing: border-box;
    background: #333; height: auto; 
  }

  .cell.card {
    background: var(--card-bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    border: 1px solid #444;
  }
  
  @keyframes flash {
    0%, 100% { border-color: #444; box-shadow: none; transform: scale(1.0); z-index: 1; }
    50% { border-color: #ff0; box-shadow: 0 0 30px #ff0; transform: scale(1.1); z-index: 100; }
  }
  .cell.highlight {
    animation: flash 1s ease-in-out 3;
  }

  .cell.card img {
    width: 100%; height: auto; display: block; 
    pointer-events: none; aspect-ratio: 4/3; 
    object-fit: contain; background: #000;
  }
  .cell.card .placeholder-icon {
    width: 100%; aspect-ratio: 4/3; background: #000;
    display: flex; align-items: center; justify-content: center;
    color: #555; font-size: calc(24px * var(--zoom));
  }

  .cell.card .info-area {
    padding: 2px 2px;
    background: var(--card-bg);
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;     
    flex-grow: 0; min-height: 20px; transition: min-height 0.2s;
  }
  .info-title { 
    font-weight: bold; font-size: 11px; color: #eee; 
    line-height: 1.1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 100%; margin-bottom: 0;
  }
  .info-sub { 
    display: none; font-size: 10px; color: #aaa; 
    line-height: 1.1; white-space: nowrap;
  }
  .board.view-detail .cell.card .info-area {
    flex-direction: row; align-items: center; justify-content: center; gap: 4px; 
  }
  .board.view-detail .info-sub { display: inline-block; }
  .board.view-detail .info-sub::before { content: "("; }
  .board.view-detail .info-sub::after { content: ")"; }

  .cell.spacer {
    background: rgba(255,255,255,0.03); border: 1px dashed rgba(255,255,255,0.1);
  }
  .cell.spacer::before { content: ""; display: block; width: 100%; aspect-ratio: 4/3; }
  .cell.spacer::after { content: ""; display: block; flex-grow: 1; min-height: 20px; border-top: 1px solid rgba(255,255,255,0.05); }

  .cell.is-placeholder { opacity: 0.15; border: 1px dashed #666; filter: grayscale(100%); }
  .cell.pressed { transform: scale(0.95); transition: transform 0.1s; filter: brightness(1.2); }
  body.is-dragging { touch-action: none; overflow: hidden; }

  .ghost {
    position: fixed; z-index: 9999; width: 120px;
    border-radius: 6px; overflow: hidden;
    box-shadow: 0 20px 50px rgba(0,0,0,0.8); pointer-events: none;
    background: var(--card-bg); border: 1px solid #aaa; opacity: 0.95;
    transform: translate(-50%, -110%) scale(1.1); 
  }
  .ghost img { width: 100%; aspect-ratio: 4/3; display: block; }
  .ghost .info-area { padding: 4px; background: #222; display: block; }
  .ghost .info-title { font-size: 12px; font-weight: bold; color: #fff; }
  .ghost .info-sub { display: block; font-size: 10px; color: #aaa; }

  .modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
    z-index: 20000; display: none;
    align-items: center; justify-content: center;
  }
  .modal-overlay.open { display: flex; }
  
  .modal-window {
    width: 90%; max-width: 500px; height: 80vh;
    background: #1a1a1a; border-radius: 12px;
    display: flex; flex-direction: column;
    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    border: 1px solid #333; overflow: hidden;
  }
  
  .modal-header {
    padding: 16px; background: #222; border-bottom: 1px solid #333;
    display: flex; justify-content: space-between; align-items: center;
  }
  .modal-title { font-weight: bold; font-size: 16px; }
  .modal-close { background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer; }
  
  .modal-tabs {
    display: flex; background: #111; border-bottom: 1px solid #333;
  }
  .tab-btn {
    flex: 1; padding: 12px; background: none; border: none;
    color: #666; font-size: 14px; cursor: pointer; border-bottom: 2px solid transparent;
  }
  .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); font-weight: bold; }

  .modal-content {
    flex: 1; overflow-y: auto; padding: 0;
    -webkit-overflow-scrolling: touch;
  }
  
  .search-list { list-style: none; padding: 0; margin: 0; }
  .search-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; border-bottom: 1px solid #333;
    cursor: pointer;
  }
  .search-item:active { background: #2a2a2a; }
  
  .item-left { display: flex; align-items: center; gap: 12px; flex: 1; }
  .item-check { 
    width: 20px; height: 20px; border-radius: 4px; border: 2px solid #555;
    display: flex; align-items: center; justify-content: center;
  }
  .item-check.checked { background: var(--accent); border-color: var(--accent); color: #fff; }
  .item-check.checked::after { content: "✔"; font-size: 12px; }
  
  .item-info { display: flex; flex-direction: column; }
  .item-name { font-size: 14px; font-weight: bold; color: #eee; }
  .item-sub { font-size: 11px; color: #888; }
  
  .item-jump {
    padding: 6px 12px; background: #333; border-radius: 4px;
    font-size: 11px; color: #aaa; border: 1px solid #444;
  }

  .menu-list { padding: 16px; display: flex; flex-direction: column; gap: 12px; }
  .menu-btn {
    background: #333; border: 1px solid #444; color: #eee;
    padding: 14px; border-radius: 8px; text-align: left; font-size: 14px;
    display: flex; align-items: center; gap: 12px;
  }
  .menu-btn i { width: 20px; text-align: center; color: #888; }

  .cat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 16px; }
  .cat-btn {
    background: #252525; border: 1px solid #333; color: #ddd;
    padding: 12px; border-radius: 6px; text-align: center; font-size: 13px;
    cursor: pointer;
  }
  .cat-btn:active { background: #444; }
  
  #fileInput { display: none; }
</style>

</head>
<body>

<div id="modeIndicator" class="mode-indicator"></div>

<div class="viewport" id="viewport">
  <div id="board" class="board"></div>
</div>

<div class="toolbar">
  <button class="tool-btn" onclick="app.openSearchModal()">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span>検索・編集</span>
  </button>
  <button class="tool-btn" onclick="app.resetView()">
    <i class="fa-solid fa-layer-group"></i>
    <span id="mySelectionLabel">マイ選抜</span>
  </button>
  <button class="tool-btn" onclick="app.openSettingsModal()">
    <i class="fa-solid fa-gear"></i>
    <span>設定</span>
  </button>
</div>

<div id="searchModal" class="modal-overlay">
  <div class="modal-window">
    <div class="modal-header">
      <div class="modal-title">馬を検索・管理</div>
      <button class="modal-close" onclick="app.closeModal('searchModal')">×</button>
    </div>
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="app.switchTab('all')">全頭リスト</button>
      <button class="tab-btn" onclick="app.switchTab('sire')">父馬別</button>
      <button class="tab-btn" onclick="app.switchTab('kana')">50音順</button>
    </div>
    <div class="modal-content" id="searchContent"></div>
  </div>
</div>

<div id="settingsModal" class="modal-overlay">
  <div class="modal-window" style="height: auto;">
    <div class="modal-header">
      <div class="modal-title">設定・データ</div>
      <button class="modal-close" onclick="app.closeModal('settingsModal')">×</button>
    </div>
    <div class="menu-list">
      <div style="font-size:12px; color:#666; margin-bottom:8px;">
        ズーム: <span id="zoomDisp">100%</span>
      </div>
      <button class="menu-btn" onclick="app.exportData()">
        <i class="fa-solid fa-download"></i> データを保存 (JSON)
      </button>
      <button class="menu-btn" onclick="document.getElementById('fileInput').click()">
        <i class="fa-solid fa-upload"></i> データを読込
      </button>
      <button class="menu-btn" onclick="app.resetData()" style="color:#f55; border-color:#533;">
        <i class="fa-solid fa-trash"></i> 全データをリセット
      </button>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept=".json" onchange="app.importData(this)">

<script>
/**
 * Horse Board Logic (v25: Sire Search Trim Fix & Max Zoom)
 * - Fixed: Sire search ignoring results due to invisible whitespace.
 * - Update: Max Zoom increased to 12.0 (1200%).
 */

const CONFIG = {
  columnCount: 12, 
  minZoom: 1.0,
  maxZoom: 12.0, // ★上限を1200%へ
  detailThreshold: 2.0, 
  storageKey: "horse_board_v23_db",
  
  longPressDelay: 300, 
  doubleTapDelay: 350,
  moveThreshold: 10
};

const state = {
  masterData: [], 
  mySelectionIds: [], 
  viewMode: 'my', 
  filterType: null, 
  filterValue: null,
  zoom: 1.0,
  renderItems: [] 
};

// カナ分類マップ
const KANA_MAP = {
  "ア行": ["ア","イ","ウ","エ","オ","ァ","ィ","ゥ","ェ","ォ","ヴ"],
  "カ行": ["カ","キ","ク","ケ","コ","ガ","ギ","グ","ゲ","ゴ","ヵ","ヶ"],
  "サ行": ["サ","シ","ス","セ","ソ","ザ","ジ","ズ","ゼ","ゾ"],
  "タ行": ["タ","チ","ツ","テ","ト","ダ","ヂ","ヅ","デ","ド","ッ"],
  "ナ行": ["ナ","ニ","ヌ","ネ","ノ"],
  "ハ行": ["ハ","ヒ","フ","ヘ","ホ","バ","ビ","ブ","ベ","ボ","パ","ピ","プ","ペ","ポ"],
  "マ行": ["マ","ミ","ム","メ","モ"],
  "ヤ行": ["ヤ","ユ","ヨ","ャ","ュ","ョ"],
  "ラ行": ["ラ","リ","ル","レ","ロ"],
  "ワ行": ["ワ","ヲ","ン","ー"]
};

function generateUniqueKey() { return `obj_${Date.now()}_${state.nextId++}`; }

const app = {
  async init() {
    try {
      this.board = document.getElementById("board");
      this.viewport = document.getElementById("viewport");
      this.modeIndicator = document.getElementById("modeIndicator");
      this.mySelectionLabel = document.getElementById("mySelectionLabel");
      this.zoomDisp = document.getElementById("zoomDisp");
      
      await this.loadMasterData();
      this.loadUserState();
      
      this.updateRenderItems();
      this.render();
      this.updateZoomStyle();
      this.updateUIState();
      this.attachEvents();
    } catch(e) {
      alert("初期化エラー: " + e);
    }
  },

  async loadMasterData() {
    try {
      const res = await fetch(`data/horses.json?t=${Date.now()}`);
      if (res.ok) state.masterData = await res.json();
    } catch (e) { state.masterData = []; }
  },

  loadUserState() {
    const raw = localStorage.getItem(CONFIG.storageKey);
    if (raw) {
      try {
        const saved = JSON.parse(raw);
        state.mySelectionIds = saved.mySelectionIds || [];
        state.zoom = saved.zoom || 1.0;
      } catch(e) { console.error(e); }
    } else {
      state.mySelectionIds = state.masterData.map(h => h.id);
    }
  },

  saveUserState() {
    const data = { mySelectionIds: state.mySelectionIds, zoom: state.zoom };
    localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
  },

  updateRenderItems() {
    let items = [];
    
    if (state.viewMode === 'my') {
      state.mySelectionIds.forEach(id => {
        const horse = state.masterData.find(h => h.id === id);
        if (horse) items.push({ ...horse, type: 'card' });
      });
    } else if (state.viewMode === 'filter') {
      if (state.filterType === 'sire') {
        // ★修正: 比較時に両方ともtrim()して余計な空白を無視する
        const targetSire = state.filterValue; 
        items = state.masterData
          .filter(h => h.sire && h.sire.trim() === targetSire)
          .map(h => ({ ...h, type: 'card' }));
      } else if (state.filterType === 'kana') {
        const chars = KANA_MAP[state.filterValue] || [];
        items = state.masterData
          .filter(h => {
             const firstChar = h.name.charAt(0);
             return chars.includes(firstChar);
          })
          .map(h => ({ ...h, type: 'card' }));
      }
      items.sort((a,b) => b.id.localeCompare(a.id)); 
    }
    state.renderItems = items;
  },

  render() {
    this.board.innerHTML = "";
    const displayList = [...state.renderItems];
    const remainder = displayList.length % CONFIG.columnCount;
    if (remainder !== 0) {
      const needed = CONFIG.columnCount - remainder;
      for (let i = 0; i < needed; i++) displayList.push({ type: 'spacer' });
    }
    if (displayList.length === 0) {
       for (let i = 0; i < CONFIG.columnCount; i++) displayList.push({ type: 'spacer' });
    }

    const fragment = document.createDocumentFragment();
    displayList.forEach((item, index) => {
      const cell = this.createCell(item, index);
      fragment.appendChild(cell);
    });
    this.board.appendChild(fragment);
  },

  createCell(item, index) {
    const el = document.createElement("div");
    el.className = `cell ${item.type}`;
    el.dataset.index = index;
    el.dataset.type = item.type;
    
    if (item.type === 'card') {
      el.dataset.horseId = item.id;
      const imgPath = `assets/images/${item.id}.jpeg`;
      const sireName = item.sire || "不明";
      
      el.innerHTML = `
        <img src="${imgPath}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
        <div class="placeholder-icon" style="display:none"><i class="fa-solid fa-horse-head"></i></div>
        <div class="info-area">
          <div class="info-title">${item.name}</div>
          <div class="info-sub">${sireName}</div>
        </div>
      `;
    }
    return el;
  },

  updateZoomStyle() {
    if (!state.zoom || isNaN(state.zoom)) state.zoom = 1.0;
    document.documentElement.style.setProperty('--zoom', state.zoom);
    if(this.zoomDisp) this.zoomDisp.textContent = Math.round(state.zoom * 100) + "%";
    
    if (state.zoom >= CONFIG.detailThreshold) {
      this.board.classList.add("view-detail");
    } else {
      this.board.classList.remove("view-detail");
    }
  },
  
  updateUIState() {
    if (state.viewMode === 'my') {
      this.modeIndicator.style.display = 'none';
      this.mySelectionLabel.textContent = "マイ選抜";
      this.mySelectionLabel.parentElement.classList.add("active");
    } else {
      this.modeIndicator.style.display = 'block';
      this.modeIndicator.textContent = `${state.filterValue} (表示のみ)`;
      this.mySelectionLabel.textContent = "戻る";
      this.mySelectionLabel.parentElement.classList.remove("active");
    }
  },

  openSearchModal() {
    document.getElementById('searchModal').classList.add('open');
    this.switchTab('all'); 
  },
  openSettingsModal() {
    document.getElementById('settingsModal').classList.add('open');
  },
  closeModal(id) {
    document.getElementById(id).classList.remove('open');
  },
  
  switchTab(tab) {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    if(tab === 'all') tabs[0].classList.add('active');
    if(tab === 'sire') tabs[1].classList.add('active');
    if(tab === 'kana') tabs[2].classList.add('active');
    
    const container = document.getElementById('searchContent');
    container.innerHTML = "";
    
    if (tab === 'all') {
      this.renderSearchList(container, state.masterData);
    } else if (tab === 'sire') {
      // ★修正: リスト作成時もtrim()して重複を排除する
      const sireSet = new Set();
      state.masterData.forEach(h => {
          if (h.sire) sireSet.add(h.sire.trim());
      });
      const sires = [...sireSet].sort();

      const grid = document.createElement('div');
      grid.className = 'cat-grid';
      sires.forEach(sire => {
        const btn = document.createElement('div');
        btn.className = 'cat-btn';
        btn.textContent = sire;
        btn.onclick = () => {
          this.closeModal('searchModal');
          this.applyFilter('sire', sire);
        };
        grid.appendChild(btn);
      });
      container.appendChild(grid);
    } else if (tab === 'kana') {
      const grid = document.createElement('div');
      grid.className = 'cat-grid';
      Object.keys(KANA_MAP).forEach(row => {
        const btn = document.createElement('div');
        btn.className = 'cat-btn';
        btn.textContent = row;
        btn.onclick = () => {
           this.closeModal('searchModal');
           this.applyFilter('kana', row);
        };
        grid.appendChild(btn);
      });
      container.appendChild(grid);
    }
  },
  
  renderSearchList(container, horses) {
    const ul = document.createElement('ul');
    ul.className = 'search-list';
    const mySet = new Set(state.mySelectionIds);
    
    horses.forEach(h => {
      const isChecked = mySet.has(h.id);
      const li = document.createElement('li');
      li.className = 'search-item';
      li.innerHTML = `
        <div class="item-left" onclick="app.toggleSelection('${h.id}')">
          <div class="item-check ${isChecked ? 'checked' : ''}" id="chk_${h.id}"></div>
          <div class="item-info">
            <div class="item-name">${h.name}</div>
            <div class="item-sub">${h.sire}</div>
          </div>
        </div>
        <div class="item-jump" onclick="app.jumpToHorse('${h.id}')">
          <i class="fa-solid fa-location-arrow"></i> ジャンプ
        </div>
      `;
      ul.appendChild(li);
    });
    container.appendChild(ul);
  },
  
  toggleSelection(id) {
    const idx = state.mySelectionIds.indexOf(id);
    const el = document.getElementById(`chk_${id}`);
    
    if (idx >= 0) {
      state.mySelectionIds.splice(idx, 1);
      if(el) el.classList.remove('checked');
    } else {
      state.mySelectionIds.push(id);
      if(el) el.classList.add('checked');
    }
    this.saveUserState();
    if (state.viewMode === 'my') {
        this.updateRenderItems();
        this.render();
    }
  },
  
  jumpToHorse(id) {
    this.closeModal('searchModal');
    
    if (state.viewMode !== 'my') {
      this.resetView(); 
    }
    
    if (!state.mySelectionIds.includes(id)) {
      state.mySelectionIds.push(id);
      this.saveUserState();
      this.updateRenderItems();
      this.render();
    }
    
    setTimeout(() => {
      const target = document.querySelector(`.cell[data-horse-id="${id}"]`);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // 0.8秒待ってから点滅開始
        setTimeout(() => {
             target.classList.add('highlight');
             // 3回点滅(約3秒)後にクラスを外す
             setTimeout(() => target.classList.remove('highlight'), 3500);
        }, 800);
      } else {
        alert("表示できませんでした");
      }
    }, 100);
  },
  
  applyFilter(type, value) {
    state.viewMode = 'filter';
    state.filterType = type;
    state.filterValue = value;
    
    this.updateRenderItems();
    this.render();
    this.updateUIState();
    this.viewport.scrollTop = 0;
  },
  
  resetView() {
    state.viewMode = 'my';
    state.filterType = null;
    state.filterValue = null;
    this.updateRenderItems();
    this.render();
    this.updateUIState();
  },

  exportData() {
    const data = { mySelectionIds: state.mySelectionIds, zoom: state.zoom };
    const str = JSON.stringify(data, null, 2);
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `horse_board_db.json`;
    a.click();
    URL.revokeObjectURL(url);
  },
  
  importData(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        if (json.mySelectionIds) {
          state.mySelectionIds = json.mySelectionIds;
          state.zoom = json.zoom || 1.0;
          this.saveUserState();
          this.resetView(); 
          alert("設定を読み込みました");
        }
      } catch(err) { alert("データ形式が違います"); }
    };
    reader.readAsText(file);
    input.value = "";
  },
  
  resetData() {
    if(!confirm("マイ選抜リストをリセットして全馬表示に戻しますか？")) return;
    localStorage.removeItem(CONFIG.storageKey);
    location.reload();
  },

  attachEvents() {
    let pointerId = null;
    let startX=0, startY=0;
    let dragTimer = null;
    let lastTapTime = 0;
    let isDragging = false;
    let isMultiTouch = false;
    let isMoving = false;
    let dragEl = null;     
    let ghostEl = null;    
    let currentIndex = -1;

    window.addEventListener("keydown", (e) => {
      if (e.target.tagName === 'INPUT') return;
      if (e.key === "+" || e.key === "=") { this.applyZoom(0.1); e.preventDefault(); }
      else if (e.key === "-") { this.applyZoom(-0.1); e.preventDefault(); }
      else if (e.key === "0") { state.zoom = 1.0; this.updateZoomStyle(); this.saveUserState(); e.preventDefault(); }
    });
    
    const showDetail = (el) => {
      el.classList.add("pressed");
      setTimeout(()=> el.classList.remove("pressed"), 200);
      const horseId = el.dataset.horseId;
      if (horseId) window.open(`https://db.netkeiba.com/horse/${horseId}`, '_blank'); 
    };

    const startDrag = (el, x, y) => {
      if (state.viewMode !== 'my') return;
      if (isMultiTouch || isMoving) return;

      isDragging = true;
      document.body.classList.add("is-dragging"); 
      
      dragEl = el;
      if (pointerId && dragEl.setPointerCapture) {
        try { dragEl.setPointerCapture(pointerId); } catch(e){}
      }
      
      dragEl.classList.add("is-placeholder");
      currentIndex = Number(dragEl.dataset.index);
      
      ghostEl = el.cloneNode(true);
      ghostEl.className = "ghost";
      ghostEl.classList.remove("is-placeholder", "pressed");
      const rect = el.getBoundingClientRect();
      ghostEl.style.width = rect.width + "px";
      ghostEl.style.height = rect.height + "px";
      document.body.appendChild(ghostEl);
      updateGhost(x, y);
      
      if (navigator.vibrate) navigator.vibrate(50);
    };

    const updateGhost = (x, y) => {
      if (ghostEl) {
        ghostEl.style.left = x + "px";
        ghostEl.style.top = y + "px";
      }
    };

    this.board.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;
      if (isMultiTouch) return;
      const cell = e.target.closest(".cell");
      if (!cell || cell.dataset.type !== 'card') return; 

      pointerId = e.pointerId;
      startX = e.clientX; startY = e.clientY;
      isMoving = false;
      cell.classList.add("pressed");

      dragTimer = setTimeout(() => {
        if (!isMoving) startDrag(cell, e.clientX, e.clientY);
      }, CONFIG.longPressDelay);
    });

    this.board.addEventListener("pointermove", (e) => {
      if (e.pointerId !== pointerId) return;

      if (isDragging) {
        e.preventDefault(); 
        updateGhost(e.clientX, e.clientY);
        handleSwapLogic(e.clientX, e.clientY);
        return;
      }

      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      if (dx > CONFIG.moveThreshold || dy > CONFIG.moveThreshold) { 
        isMoving = true;
        if (dragTimer) clearTimeout(dragTimer);
        const cell = e.target.closest(".cell");
        if (cell) cell.classList.remove("pressed");
      }
    });

    this.viewport.addEventListener("touchmove", (e) => {
      if (isDragging) e.preventDefault();
    }, { passive: false });

    const handleSwapLogic = (x, y) => {
      if (ghostEl) ghostEl.style.display = 'none';
      let target = document.elementFromPoint(x, y);
      if (ghostEl) ghostEl.style.display = 'block';

      if (!target) return;
      const targetCell = target.closest('.cell');
      
      if (targetCell && targetCell !== dragEl && this.board.contains(targetCell) && targetCell.dataset.type === 'card') {
        const targetIndex = Number(targetCell.dataset.index);
        
        const fromId = dragEl.dataset.horseId;
        const toId = targetCell.dataset.horseId;
        
        const fromIdxState = state.mySelectionIds.indexOf(fromId);
        const toIdxState = state.mySelectionIds.indexOf(toId);
        
        if (fromIdxState >= 0 && toIdxState >= 0) {
            const temp = state.mySelectionIds[fromIdxState];
            state.mySelectionIds[fromIdxState] = state.mySelectionIds[toIdxState];
            state.mySelectionIds[toIdxState] = temp;
            
            const tempItem = state.renderItems[currentIndex];
            state.renderItems[currentIndex] = state.renderItems[targetIndex];
            state.renderItems[targetIndex] = tempItem;

            const dragHtml = dragEl.innerHTML;
            const dragIdAttr = dragEl.dataset.horseId;
            
            dragEl.innerHTML = targetCell.innerHTML;
            dragEl.dataset.horseId = targetCell.dataset.horseId;
            dragEl.classList.remove("is-placeholder"); 

            targetCell.innerHTML = dragHtml;
            targetCell.dataset.horseId = dragIdAttr;
            targetCell.classList.add("is-placeholder");

            dragEl = targetCell;
            currentIndex = targetIndex;
            if(pointerId) { try{ dragEl.setPointerCapture(pointerId); }catch(e){} }
        }
      }
    };

    const endInteraction = (e) => {
      if (pointerId && e.pointerId !== pointerId) return;
      if (dragTimer) clearTimeout(dragTimer);

      const cell = e.target.closest(".cell");
      
      if (isDragging) {
        isDragging = false;
        document.body.classList.remove("is-dragging");
        if (ghostEl) ghostEl.remove();
        if (dragEl) dragEl.classList.remove("is-placeholder");
        if (cell) cell.classList.remove("pressed");
        this.saveUserState(); 
      } else {
        if (!isMoving && cell && cell.dataset.type === 'card') {
            cell.classList.remove("pressed");
            const now = Date.now();
            if (now - lastTapTime < CONFIG.doubleTapDelay) {
                showDetail(cell);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
      }
      pointerId = null;
    };

    this.board.addEventListener("pointerup", endInteraction);
    this.board.addEventListener("pointercancel", endInteraction);
    
    let initialDist = 0;
    let initialZoom = 1.0;
    this.viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length >= 2) {
        isMultiTouch = true;
        if (isDragging) endInteraction(e); 
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialDist = Math.hypot(dx, dy);
        initialZoom = state.zoom;
        e.preventDefault(); 
      }
    }, { passive: false });

    this.viewport.addEventListener("touchmove", (e) => {
      if (isMultiTouch && e.touches.length >= 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        if (initialDist > 0) {
           const ratio = dist / initialDist;
           const newZoom = Math.min(Math.max(initialZoom * ratio, CONFIG.minZoom), CONFIG.maxZoom);
           state.zoom = newZoom;
           this.updateZoomStyle();
        }
      }
    }, { passive: false });

    this.viewport.addEventListener("touchend", (e) => {
      if (e.touches.length < 2) {
        isMultiTouch = false;
        this.saveUserState();
      }
    });
    
    this.viewport.addEventListener("wheel", (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY * -0.01;
        this.applyZoom(delta);
      }
    }, { passive: false });
  },

  applyZoom(delta) {
    let newZoom = state.zoom + delta;
    newZoom = Math.min(Math.max(newZoom, CONFIG.minZoom), CONFIG.maxZoom);
    state.zoom = newZoom;
    this.updateZoomStyle();
    if (this.zoomTimer) clearTimeout(this.zoomTimer);
    this.zoomTimer = setTimeout(()=> this.saveUserState(), 500);
  }
};

app.init();
</script>
</body>
</html>