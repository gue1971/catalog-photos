<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Horse Board (V36: Index & Ledger)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --bg: #222;
    --card-bg: #111;
    --text-color: #eee;
    --accent: #0078ff;
    --zoom: 1.0;
    --gap: 2px;
  }

  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Yu Gothic", sans-serif;
    background: var(--bg);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation; 
  }

  /* ツールバー */
  .toolbar {
    position: fixed; bottom: 0; left: 0; right: 0;
    height: 54px;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
    gap: 80px; 
    padding: 0 16px; z-index: 10000;
    border-top: 1px solid rgba(255,255,255,0.15);
    transition: background 0.3s;
  }
  
  .tool-btn {
    background: none; border: none;
    color: #888; display: flex; flex-direction: column; align-items: center; justify-content: center;
    font-size: 10px; gap: 0; cursor: pointer;
    width: 60px; height: 100%;
  }
  .tool-btn i { font-size: 24px; margin-bottom: 0; }
  .tool-btn:active { transform: scale(0.90); color: #fff; }

  /* フィルターモード用ツールバー */
  .toolbar.mode-filter {
    background: #002a55; 
    justify-content: space-between; 
    gap: 8px; 
  }
  
  .filter-status {
    color: #fff; font-size: 14px; font-weight: bold;
    display: flex; flex-direction: column; align-items: center;
    line-height: 1.2;
    flex: 1; 
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .filter-status span { font-size: 10px; opacity: 0.8; font-weight: normal; }
  
  .filter-btn {
    background: rgba(255,255,255,0.15); color: #fff;
    border: 1px solid rgba(255,255,255,0.3); border-radius: 20px;
    padding: 8px 16px; font-size: 13px; font-weight: bold;
    cursor: pointer; display: flex; align-items: center; gap: 6px;
    white-space: nowrap;
  }
  .filter-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.25); }
  .filter-btn.primary {
    background: #fff; color: #002a55; border: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  .viewport {
    width: 100vw;
    height: calc(100vh - 54px);
    overflow: auto; 
    position: relative;
    -webkit-overflow-scrolling: touch; 
    touch-action: manipulation;
  }

  /* --- ボードレイアウト --- */
  .board {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: calc(var(--gap) * var(--zoom));
    width: calc(100% * var(--zoom));
    padding: 8px;
    box-sizing: border-box;
    padding-bottom: 300px; 
    transform-origin: 0 0;
  }

  .board.mode-filter {
    display: flex;
    flex-wrap: wrap;
    width: 100%;
    justify-content: flex-start;
    align-content: flex-start;
    gap: 0; 
    padding: 8px;
    padding-bottom: 400px; 
  }

  /* --- セルスタイル --- */
  .cell {
    position: relative;
    border-radius: calc(2px * var(--zoom));
    overflow: hidden;
    touch-action: manipulation;
    display: flex; flex-direction: column;
    box-sizing: border-box;
    background: #333; height: auto; 
  }

  .board.mode-filter .cell {
    width: calc( (100% / 6) * var(--zoom) - 6px );
    margin: 3px;
    max-width: 90vw; 
    border-radius: 4px;
    flex-grow: 0; flex-shrink: 0;
  }

  .cell.card {
    background: var(--card-bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    border: 1px solid #444;
  }
  
  .cell.card img {
    width: 100%; height: auto; display: block; 
    pointer-events: none; aspect-ratio: 4/3; 
    object-fit: contain; background: #000;
  }
  .cell.card .placeholder-icon {
    width: 100%; aspect-ratio: 4/3; background: #000;
    display: flex; align-items: center; justify-content: center;
    color: #555; font-size: calc(24px * var(--zoom));
  }

  .cell.card .info-area {
    padding: 2px 4px;
    background: var(--card-bg);
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;     
    flex-grow: 0; min-height: 20px; transition: min-height 0.2s;
    overflow: hidden;
  }

  .info-title { 
    font-weight: bold; font-size: 11px; color: #eee; 
    line-height: 1.1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    margin-bottom: 0; max-width: 100%;
  }
  
  .info-sub { 
    display: none; font-size: 10px; color: #aaa; 
    line-height: 1.1; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis;
  }
  
  .board.view-detail .cell.card .info-area,
  .board.mode-filter .cell.card .info-area {
    flex-direction: row; align-items: baseline; justify-content: center; 
    gap: 4px; flex-wrap: nowrap;
  }
  
  .board.view-detail .info-title, .board.mode-filter .info-title {
    flex-shrink: 0; min-width: auto; max-width: 100%;
  }

  .board.view-detail .info-sub, .board.mode-filter .info-sub { 
    display: inline-block; flex-shrink: 100; min-width: 0; max-width: 100%;
  }
  
  .board.view-detail .info-sub::before, .board.mode-filter .info-sub::before { content: "("; }
  .board.view-detail .info-sub::after, .board.mode-filter .info-sub::after { content: ")"; }

  .mini-check {
    display: none; width: 16px; height: 16px;
    background: #666; border-radius: 50%;
    align-items: center; justify-content: center;
    font-size: 9px; color: #000; cursor: pointer;
    margin-left: 2px; flex-shrink: 0; 
  }
  .board.mode-filter .mini-check { display: flex; }
  .mini-check.checked { background: #666; color: #fff; }
  .mini-check i { pointer-events: none; }

  @keyframes flash {
    0%, 100% { border-color: #444; box-shadow: none; transform: scale(1.0); z-index: 1; }
    50% { border-color: #ff0; box-shadow: 0 0 30px #ff0; transform: scale(1.1); z-index: 100; }
  }
  .cell.highlight { animation: flash 1s ease-in-out 3; }

  .cell.spacer {
    background: rgba(255,255,255,0.03); border: 1px dashed rgba(255,255,255,0.1);
  }
  .cell.spacer::before { content: ""; display: block; width: 100%; aspect-ratio: 4/3; }
  .cell.spacer::after { content: ""; display: block; flex-grow: 1; min-height: 20px; border-top: 1px solid rgba(255,255,255,0.05); }

  .cell.is-placeholder { opacity: 0.15; border: 1px dashed #666; filter: grayscale(100%); }
  .cell.pressed { transform: scale(0.95); transition: transform 0.1s; filter: brightness(1.2); }
  body.is-dragging { touch-action: none; overflow: hidden; }

  .ghost {
    position: fixed; z-index: 9999; width: 120px;
    border-radius: 6px; overflow: hidden;
    box-shadow: 0 20px 50px rgba(0,0,0,0.8); pointer-events: none;
    background: var(--card-bg); border: 1px solid #aaa; opacity: 0.95;
    transform: translate(-50%, -110%) scale(1.1); 
  }
  .ghost img { width: 100%; aspect-ratio: 4/3; display: block; }
  .ghost .info-area { padding: 4px; background: #222; display: block; }
  .ghost .info-title { font-size: 12px; font-weight: bold; color: #fff; }
  .ghost .info-sub { display: block; font-size: 10px; color: #aaa; }

  /* モーダル */
  .modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
    z-index: 20000; display: none;
    align-items: center; justify-content: center;
  }
  .modal-overlay.open { display: flex; }
  
  .modal-window {
    width: 90%; max-width: 500px; height: 80vh;
    background: #1a1a1a; border-radius: 12px;
    display: flex; flex-direction: column;
    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
    border: 1px solid #333; overflow: hidden;
  }
  
  .modal-header {
    padding: 16px; background: #222; border-bottom: 1px solid #333;
    display: flex; justify-content: space-between; align-items: center;
  }
  .modal-title { font-weight: bold; font-size: 16px; }
  .modal-close { background: none; border: none; color: #aaa; font-size: 24px; cursor: pointer; }
  
  .modal-tabs {
    display: flex; background: #111; border-bottom: 1px solid #333; flex-shrink: 0;
  }
  .tab-btn {
    flex: 1; padding: 12px; background: none; border: none;
    color: #666; font-size: 14px; cursor: pointer; border-bottom: 2px solid transparent;
  }
  .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); font-weight: bold; }

  /* 管理・台帳用コントロールバー */
  .control-bar {
    background: #1e1e1e; padding: 8px 12px;
    display: flex; flex-direction: column; gap: 8px;
    border-bottom: 1px solid #333;
  }
  .ctrl-row { display: flex; gap: 8px; overflow-x: auto; }
  .ctrl-btn {
    flex: 1; padding: 6px 4px; font-size: 11px;
    background: #333; border: 1px solid #444; color: #aaa;
    border-radius: 4px; cursor: pointer; white-space: nowrap;
    text-align: center;
  }
  .ctrl-btn.active { background: #3d3d3d; color: var(--accent); border-color: var(--accent); font-weight: bold; }

  .modal-content {
    flex: 1; overflow-y: auto; padding: 0;
    -webkit-overflow-scrolling: touch;
  }
  
  .search-list { list-style: none; padding: 0; margin: 0; }
  .search-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px; border-bottom: 1px solid #333;
    cursor: pointer;
  }
  .search-item:active { background: #2a2a2a; }
  
  .item-left { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
  .item-check { 
    width: 20px; height: 20px; border-radius: 4px; border: 2px solid #555;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0; 
  }
  .item-check.checked { background: var(--accent); border-color: var(--accent); color: #fff; }
  .item-check.checked::after { content: "✔"; font-size: 12px; }
  
  .item-info { display: flex; flex-direction: row; align-items: baseline; gap: 8px; overflow: hidden; flex: 1; min-width: 0; }
  .item-name { font-size: 14px; font-weight: bold; color: #eee; white-space: nowrap; flex-shrink: 0; }
  .item-sub { font-size: 11px; color: #888; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 1; min-width: 0; }
  
  .item-jump {
    padding: 6px 12px; background: #333; border-radius: 4px;
    font-size: 11px; color: #aaa; border: 1px solid #444;
    flex-shrink: 0; margin-left: 8px;
  }
  /* ジャンプ専用タブでのアイテム */
  .jump-only-item { padding: 14px 16px; font-size: 14px; color: #eee; border-bottom: 1px solid #333; cursor: pointer; }
  .jump-only-item:active { background: var(--accent); color: #fff; }
  .jump-sub { font-size: 11px; color: #888; margin-left: 8px; }

  .menu-list { padding: 16px; display: flex; flex-direction: column; gap: 12px; }
  .menu-btn {
    background: #333; border: 1px solid #444; color: #eee;
    padding: 14px; border-radius: 8px; text-align: left; font-size: 14px;
    display: flex; align-items: center; gap: 12px;
  }
  .menu-btn i { width: 20px; text-align: center; color: #888; }

  .cat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 16px; }
  .cat-btn {
    background: #252525; border: 1px solid #333; color: #ddd;
    padding: 12px; border-radius: 6px; text-align: center; font-size: 13px;
    cursor: pointer;
    display: flex; justify-content: space-between; align-items: center;
  }
  .cat-btn:active { background: #444; }
  .cat-btn.disabled { opacity: 0.3; pointer-events: none; }
  .cat-count { background: #444; padding: 2px 6px; border-radius: 10px; font-size: 11px; color: #ccc; }
  
  .back-btn {
    display: flex; align-items: center; gap: 8px;
    padding: 12px 16px; background: #222; border-bottom: 1px solid #333;
    color: var(--accent); font-size: 14px; cursor: pointer; font-weight: bold;
  }
  
  #fileInput { display: none; }
</style>

</head>
<body>

<div class="viewport" id="viewport">
  <div id="board" class="board"></div>
</div>

<div id="toolbar" class="toolbar"></div>

<div id="searchModal" class="modal-overlay">
  <div class="modal-window">
    <div class="modal-header">
      <div class="modal-title">馬を検索・管理</div>
      <button class="modal-close" onclick="app.closeModal('searchModal')">×</button>
    </div>
    <div class="modal-tabs">
      <button class="tab-btn active" onclick="app.switchTab('sire')">種牡馬</button>
      <button class="tab-btn" onclick="app.switchTab('kana')">50音順</button>
      <button class="tab-btn" onclick="app.switchTab('all')">全頭リスト</button>
    </div>
    <div class="modal-content" id="searchContent"></div>
  </div>
</div>

<div id="settingsModal" class="modal-overlay">
  <div class="modal-window" style="height: auto;">
    <div class="modal-header">
      <div class="modal-title">設定・データ</div>
      <button class="modal-close" onclick="app.closeModal('settingsModal')">×</button>
    </div>
    <div class="menu-list">
      <div style="font-size:12px; color:#666; margin-bottom:8px;">
        ズーム: <span id="zoomDisp">100%</span>
      </div>
      <button class="menu-btn" onclick="app.exportData()">
        <i class="fa-solid fa-download"></i> データを保存 (JSON)
      </button>
      <button class="menu-btn" onclick="document.getElementById('fileInput').click()">
        <i class="fa-solid fa-upload"></i> データを読込
      </button>
      <button class="menu-btn" onclick="app.resetData()" style="color:#f55; border-color:#533;">
        <i class="fa-solid fa-trash"></i> 全データをリセット
      </button>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept=".json" onchange="app.importData(this)">

<script>
/**
 * Horse Board Logic (V36: Index Jump & Ledger)
 * - 50-sound tab is now purely for jumping (Index).
 * - All List tab now has Sort and Filter controls (Ledger).
 */

const CONFIG = {
  columnCount: 12, 
  minZoom: 1.0,
  maxZoom: 12.0, 
  detailThreshold: 2.0, 
  storageKey: "horse_board_v23_db",
  
  longPressDelay: 300, 
  doubleTapDelay: 350,
  moveThreshold: 10
};

const state = {
  masterData: [], 
  mySelectionIds: [], 
  viewMode: 'my', 
  filterType: null, 
  filterValue: null,
  zoom: 1.0,
  renderItems: [],
  activeTab: 'sire',
  // 管理台帳用の状態
  listFilter: 'all', // all, checked, unchecked
  listSort: 'id'     // id, name, sire
};

const KANA_MAP = {
  "ア行": ["ア","イ","ウ","エ","オ","ァ","ィ","ゥ","ェ","ォ","ヴ"],
  "カ行": ["カ","キ","ク","ケ","コ","ガ","ギ","グ","ゲ","ゴ","ヵ","ヶ"],
  "サ行": ["サ","シ","ス","セ","ソ","ザ","ジ","ズ","ゼ","ゾ"],
  "タ行": ["タ","チ","ツ","テ","ト","ダ","ヂ","ヅ","デ","ド","ッ"],
  "ナ行": ["ナ","ニ","ヌ","ネ","ノ"],
  "ハ行": ["ハ","ヒ","フ","ヘ","ホ","バ","ビ","ブ","ベ","ボ","パ","ピ","プ","ペ","ポ"],
  "マ行": ["マ","ミ","ム","メ","モ"],
  "ヤ行": ["ヤ","ユ","ヨ","ャ","ュ","ョ"],
  "ラ行": ["ラ","リ","ル","レ","ロ"],
  "ワ行": ["ワ","ヲ","ン","ー"]
};

function generateUniqueKey() { return `obj_${Date.now()}_${state.nextId++}`; }

const app = {
  async init() {
    try {
      this.board = document.getElementById("board");
      this.viewport = document.getElementById("viewport");
      this.toolbar = document.getElementById("toolbar");
      this.zoomDisp = document.getElementById("zoomDisp");
      
      await this.loadMasterData();
      this.loadUserState();
      
      this.updateRenderItems();
      this.updateUIState();
      this.render();
      this.updateZoomStyle();
      this.attachEvents();
    } catch(e) {
      alert("初期化エラー: " + e);
    }
  },

  async loadMasterData() {
    try {
      const res = await fetch(`data/horses.json?t=${Date.now()}`);
      if (res.ok) state.masterData = await res.json();
    } catch (e) { state.masterData = []; }
  },

  loadUserState() {
    const raw = localStorage.getItem(CONFIG.storageKey);
    if (raw) {
      try {
        const saved = JSON.parse(raw);
        state.mySelectionIds = saved.mySelectionIds || [];
        state.zoom = saved.zoom || 1.0;
      } catch(e) { console.error(e); }
    } else {
      state.mySelectionIds = state.masterData.map(h => h.id);
    }
  },

  saveUserState() {
    const data = { mySelectionIds: state.mySelectionIds, zoom: state.zoom };
    localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
  },

  updateRenderItems() {
    let items = [];
    
    if (state.viewMode === 'my') {
      state.mySelectionIds.forEach(id => {
        const horse = state.masterData.find(h => h.id === id);
        if (horse) items.push({ ...horse, type: 'card' });
      });
    } else if (state.viewMode === 'filter') {
      if (state.filterType === 'sire') {
        const targetSire = state.filterValue; 
        items = state.masterData
          .filter(h => h.sire && h.sire.trim() === targetSire)
          .map(h => ({ ...h, type: 'card' }));
      } 
      // 50音フィルターモードは廃止したので削除
      items.sort((a,b) => b.id.localeCompare(a.id)); 
    }
    state.renderItems = items;
  },

  render() {
    this.board.innerHTML = "";
    const displayList = [...state.renderItems];
    
    if (state.viewMode === 'my') {
        this.board.classList.remove('mode-filter');
        const remainder = displayList.length % CONFIG.columnCount;
        if (remainder !== 0) {
          const needed = CONFIG.columnCount - remainder;
          for (let i = 0; i < needed; i++) displayList.push({ type: 'spacer' });
        }
        if (displayList.length === 0) {
           for (let i = 0; i < CONFIG.columnCount; i++) displayList.push({ type: 'spacer' });
        }
    } else {
        this.board.classList.add('mode-filter');
    }

    const fragment = document.createDocumentFragment();
    displayList.forEach((item, index) => {
      const cell = this.createCell(item, index);
      fragment.appendChild(cell);
    });
    this.board.appendChild(fragment);
  },

  createCell(item, index) {
    const el = document.createElement("div");
    el.className = `cell ${item.type}`;
    el.dataset.index = index;
    el.dataset.type = item.type;
    
    if (item.type === 'card') {
      el.dataset.horseId = item.id;
      const imgPath = `assets/images/${item.id}.jpeg`;
      const sireName = item.sire || "不明";
      
      const isSelected = state.mySelectionIds.includes(item.id);
      
      el.innerHTML = `
        <img src="${imgPath}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
        <div class="placeholder-icon" style="display:none"><i class="fa-solid fa-horse-head"></i></div>
        <div class="info-area">
          <div class="info-title">${item.name}</div>
          <div class="info-sub">${sireName}</div>
          <div class="mini-check ${isSelected ? 'checked' : ''}" onclick="app.toggleSelectionOnCard('${item.id}', this, event)">
            <i class="fa-solid fa-check"></i>
          </div>
        </div>
      `;
    }
    return el;
  },
  
  toggleSelectionOnCard(id, btnEl, e) {
    e.stopPropagation(); 
    const idx = state.mySelectionIds.indexOf(id);
    if (idx >= 0) {
        state.mySelectionIds.splice(idx, 1);
        btnEl.classList.remove('checked');
    } else {
        state.mySelectionIds.push(id);
        btnEl.classList.add('checked');
    }
    this.saveUserState();
  },

  updateZoomStyle() {
    if (!state.zoom || isNaN(state.zoom)) state.zoom = 1.0;
    document.documentElement.style.setProperty('--zoom', state.zoom);
    if(this.zoomDisp) this.zoomDisp.textContent = Math.round(state.zoom * 100) + "%";
    
    if (state.zoom >= CONFIG.detailThreshold) {
      this.board.classList.add("view-detail");
    } else {
      this.board.classList.remove("view-detail");
    }
  },
  
  updateUIState() {
    if (state.viewMode === 'my') {
      this.toolbar.classList.remove('mode-filter');
      this.toolbar.innerHTML = `
        <button class="tool-btn" onclick="app.openSearchModal()">
          <i class="fa-solid fa-magnifying-glass"></i>
        </button>
        <button class="tool-btn" onclick="app.openSettingsModal()">
          <i class="fa-solid fa-gear"></i>
        </button>
      `;
    } else {
      this.toolbar.classList.add('mode-filter');
      this.toolbar.innerHTML = `
        <button class="filter-btn" onclick="app.openSearchModal()">
            <i class="fa-solid fa-magnifying-glass"></i> 条件変更
        </button>
        <div class="filter-status">
            <span>表示中:</span>
            ${state.filterValue} (${state.renderItems.length}頭)
        </div>
        <button class="filter-btn primary" onclick="app.resetView()">
            <i class="fa-solid fa-arrow-left"></i> マイ選抜へ
        </button>
      `;
    }
  },

  openSearchModal() {
    document.getElementById('searchModal').classList.add('open');
    this.switchTab(state.activeTab); 
  },
  openSettingsModal() {
    document.getElementById('settingsModal').classList.add('open');
  },
  closeModal(id) {
    document.getElementById(id).classList.remove('open');
  },
  
  switchTab(tab) {
    state.activeTab = tab; 
    
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    
    if(tab === 'sire') tabs[0].classList.add('active');
    if(tab === 'kana') tabs[1].classList.add('active');
    if(tab === 'all')  tabs[2].classList.add('active');
    
    const container = document.getElementById('searchContent');
    container.innerHTML = "";
    
    if (tab === 'all') {
      this.renderAllTab(container);
    } else if (tab === 'sire') {
      this.renderSireTab(container);
    } else if (tab === 'kana') {
      this.renderKanaRows(container);
    }
  },

  // --- 種牡馬タブ (既存ロジック維持) ---
  renderSireTab(container) {
    const stats = {};
    state.masterData.forEach(h => {
      const s = h.sire ? h.sire.trim() : "不明";
      if(!stats[s]) stats[s] = { total: 0, checked: 0 };
      stats[s].total++;
      if(state.mySelectionIds.includes(h.id)) stats[s].checked++;
    });

    const sires = Object.keys(stats).sort();
    const grid = document.createElement('div');
    grid.className = 'cat-grid';
    sires.forEach(sire => {
      const info = stats[sire];
      const btn = document.createElement('div');
      btn.className = 'cat-btn';
      btn.innerHTML = `<span>${sire}</span> <span class="cat-count">${info.total} (${info.checked})</span>`;
      btn.onclick = () => {
        this.closeModal('searchModal');
        this.applyFilter('sire', sire);
      };
      grid.appendChild(btn);
    });
    container.appendChild(grid);
  },

  // --- 50音（索引・ジャンプ） ---
  countKana(chars) {
    return state.masterData.filter(h => chars.includes(h.name.charAt(0))).length;
  },
  
  renderKanaRows(container) {
    container.innerHTML = "";
    const grid = document.createElement('div');
    grid.className = 'cat-grid';
    
    Object.keys(KANA_MAP).forEach(rowKey => {
      const chars = KANA_MAP[rowKey];
      const count = this.countKana(chars);
      
      const btn = document.createElement('div');
      btn.className = `cat-btn ${count === 0 ? 'disabled' : ''}`;
      btn.innerHTML = `<span>${rowKey}</span> <span class="cat-count">${count}</span>`;
      
      if (count > 0) {
        btn.onclick = () => {
            this.renderKanaSub(container, rowKey);
        };
      }
      grid.appendChild(btn);
    });
    container.appendChild(grid);
  },
  
  renderKanaSub(container, rowKey) {
    container.innerHTML = "";
    const backBtn = document.createElement('div');
    backBtn.className = 'back-btn';
    backBtn.innerHTML = '<i class="fa-solid fa-chevron-left"></i> 戻る';
    backBtn.onclick = () => { this.renderKanaRows(container); };
    container.appendChild(backBtn);
    
    const grid = document.createElement('div');
    grid.className = 'cat-grid';
    
    const chars = KANA_MAP[rowKey];
    chars.forEach(char => {
        const count = this.countKana([char]);
        const btn = document.createElement('div');
        btn.className = `cat-btn ${count === 0 ? 'disabled' : ''}`;
        btn.innerHTML = `<span>${char}</span> <span class="cat-count">${count}</span>`;
        if (count > 0) {
            btn.onclick = () => {
                this.renderKanaFinalList(container, char, rowKey);
            };
        }
        grid.appendChild(btn);
    });
    container.appendChild(grid);
  },

  // 50音の最終リスト（クリックで即ジャンプ）
  renderKanaFinalList(container, char, rowKey) {
    container.innerHTML = "";
    const backBtn = document.createElement('div');
    backBtn.className = 'back-btn';
    backBtn.innerHTML = `<i class="fa-solid fa-chevron-left"></i> ${rowKey}に戻る`;
    backBtn.onclick = () => { this.renderKanaSub(container, rowKey); };
    container.appendChild(backBtn);

    const targetHorses = state.masterData
      .filter(h => h.name.charAt(0) === char)
      .sort((a,b) => a.name.localeCompare(b.name, 'ja'));
    
    const ul = document.createElement('ul');
    ul.className = 'search-list';
    
    targetHorses.forEach(h => {
      const isChecked = state.mySelectionIds.includes(h.id);
      const li = document.createElement('li');
      li.className = 'jump-only-item';
      li.innerHTML = `
        <span style="${isChecked ? 'color:var(--accent); font-weight:bold;' : ''}">
          ${h.name} ${isChecked ? '✔' : ''}
        </span>
        <span class="jump-sub">${h.sire}</span>
      `;
      // クリックで即ジャンプ
      li.onclick = () => {
        this.jumpToHorse(h.id);
      };
      ul.appendChild(li);
    });
    container.appendChild(ul);
  },

  // --- 全頭リスト（管理台帳） ---
  renderAllTab(container) {
    // コントロールバーの生成
    const ctrl = document.createElement('div');
    ctrl.className = 'control-bar';
    ctrl.innerHTML = `
      <div class="ctrl-row">
        <div class="ctrl-btn ${state.listFilter==='all'?'active':''}" onclick="app.setListFilter('all')">すべて</div>
        <div class="ctrl-btn ${state.listFilter==='checked'?'active':''}" onclick="app.setListFilter('checked')">選択済</div>
        <div class="ctrl-btn ${state.listFilter==='unchecked'?'active':''}" onclick="app.setListFilter('unchecked')">未選択</div>
      </div>
      <div class="ctrl-row">
        <div class="ctrl-btn ${state.listSort==='id'?'active':''}" onclick="app.setListSort('id')">ID順</div>
        <div class="ctrl-btn ${state.listSort==='name'?'active':''}" onclick="app.setListSort('name')">名前順</div>
        <div class="ctrl-btn ${state.listSort==='sire'?'active':''}" onclick="app.setListSort('sire')">種牡馬順</div>
      </div>
    `;
    container.appendChild(ctrl);

    const listContainer = document.createElement('div');
    listContainer.id = 'ledger-list';
    container.appendChild(listContainer);
    
    this.renderAllListItems(listContainer);
  },

  setListFilter(val) {
    state.listFilter = val;
    this.switchTab('all'); // 再描画
  },
  
  setListSort(val) {
    state.listSort = val;
    this.switchTab('all'); // 再描画
  },

  renderAllListItems(container) {
    let list = [...state.masterData];

    // フィルター
    if (state.listFilter === 'checked') {
      list = list.filter(h => state.mySelectionIds.includes(h.id));
    } else if (state.listFilter === 'unchecked') {
      list = list.filter(h => !state.mySelectionIds.includes(h.id));
    }

    // ソート
    if (state.listSort === 'name') {
      list.sort((a,b) => a.name.localeCompare(b.name, 'ja'));
    } else if (state.listSort === 'sire') {
      list.sort((a,b) => {
        const sa = a.sire || "";
        const sb = b.sire || "";
        return sa.localeCompare(sb, 'ja') || a.name.localeCompare(b.name, 'ja');
      });
    } else {
      // ID順（文字列IDの場合はlocaleCompare）
      list.sort((a,b) => a.id.localeCompare(b.id));
    }

    const ul = document.createElement('ul');
    ul.className = 'search-list';
    const mySet = new Set(state.mySelectionIds);

    list.forEach(h => {
      const isChecked = mySet.has(h.id);
      const li = document.createElement('li');
      li.className = 'search-item';
      li.innerHTML = `
        <div class="item-left" onclick="app.toggleSelectionAllTab('${h.id}')">
          <div class="item-check ${isChecked ? 'checked' : ''}" id="chk_all_${h.id}"></div>
          <div class="item-info">
            <div class="item-name">${h.name}</div>
            <div class="item-sub">${h.sire}</div>
          </div>
        </div>
        <div class="item-jump" onclick="app.jumpToHorse('${h.id}')">
          <i class="fa-solid fa-location-arrow"></i>
        </div>
      `;
      ul.appendChild(li);
    });
    
    if (list.length === 0) {
      ul.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">該当する馬がいません</div>';
    }
    
    container.innerHTML = "";
    container.appendChild(ul);
  },

  // 全頭リスト用: チェック切り替え（再描画なしで高速化）
  toggleSelectionAllTab(id) {
    const idx = state.mySelectionIds.indexOf(id);
    const el = document.getElementById(`chk_all_${id}`);
    
    if (idx >= 0) {
      state.mySelectionIds.splice(idx, 1);
      if(el) el.classList.remove('checked');
    } else {
      state.mySelectionIds.push(id);
      if(el) el.classList.add('checked');
    }
    this.saveUserState();
    // ここではボードの再描画はしない（モーダル閉じた時に反映されればいい or ジャンプ時に反映）
    // ただしviewModeがmyの場合は裏で整合性を取るためにデータ更新だけしておく
    if(state.viewMode === 'my') {
       this.updateRenderItems(); // renderは重いのでしない
    }
  },
  
  toggleSelection(id) {
    // 既存のメソッド（主に種牡馬タブ用）
    const idx = state.mySelectionIds.indexOf(id);
    // ... (処理はAllTabと同じだが、DOM IDなどが違う場合への対応)
    // 簡略化のため、基本ロジックは同じ
    if (idx >= 0) state.mySelectionIds.splice(idx, 1);
    else state.mySelectionIds.push(id);
    this.saveUserState();
    this.switchTab(state.activeTab); // タブ内をリフレッシュ
  },
  
  jumpToHorse(id) {
    this.closeModal('searchModal');
    
    if (state.viewMode !== 'my') {
      this.resetView(); 
    }
    
    // 未選択なら追加
    if (!state.mySelectionIds.includes(id)) {
      state.mySelectionIds.push(id);
      this.saveUserState();
      this.updateRenderItems();
      this.render();
    } else {
      // 既に選択済みでもボードを最新にする
      this.updateRenderItems();
      this.render();
    }
    
    setTimeout(() => {
      const target = document.querySelector(`.cell[data-horse-id="${id}"]`);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => {
             target.classList.add('highlight');
             setTimeout(() => target.classList.remove('highlight'), 3500);
        }, 800);
      } else {
        alert("表示できませんでした");
      }
    }, 100);
  },
  
  applyFilter(type, value) {
    state.viewMode = 'filter';
    state.filterType = type;
    state.filterValue = value;
    
    this.updateRenderItems();
    this.updateUIState();
    this.render();
    this.viewport.scrollTop = 0;
  },
  
  resetView() {
    state.viewMode = 'my';
    state.filterType = null;
    state.filterValue = null;
    this.updateRenderItems();
    this.updateUIState();
    this.render();
  },

  exportData() {
    const data = { mySelectionIds: state.mySelectionIds, zoom: state.zoom };
    const str = JSON.stringify(data, null, 2);
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `horse_board_db.json`;
    a.click();
    URL.revokeObjectURL(url);
  },
  
  importData(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        if (json.mySelectionIds) {
          state.mySelectionIds = json.mySelectionIds;
          state.zoom = json.zoom || 1.0;
          this.saveUserState();
          this.resetView(); 
          alert("設定を読み込みました");
        }
      } catch(err) { alert("データ形式が違います"); }
    };
    reader.readAsText(file);
    input.value = "";
  },
  
  resetData() {
    if(!confirm("マイ選抜リストをリセットして全馬表示に戻しますか？")) return;
    localStorage.removeItem(CONFIG.storageKey);
    location.reload();
  },

  attachEvents() {
    let pointerId = null;
    let startX=0, startY=0;
    let dragTimer = null;
    let lastTapTime = 0;
    let isDragging = false;
    let isMultiTouch = false;
    let isMoving = false;
    let dragEl = null;     
    let ghostEl = null;    
    let currentIndex = -1;

    window.addEventListener("keydown", (e) => {
      if (e.target.tagName === 'INPUT') return;
      if (e.key === "+" || e.key === "=") { this.applyZoom(0.1); e.preventDefault(); }
      else if (e.key === "-") { this.applyZoom(-0.1); e.preventDefault(); }
      else if (e.key === "0") { state.zoom = 1.0; this.updateZoomStyle(); this.saveUserState(); e.preventDefault(); }
    });
    
    const showDetail = (el) => {
      el.classList.add("pressed");
      setTimeout(()=> el.classList.remove("pressed"), 200);
      const horseId = el.dataset.horseId;
      if (horseId) window.open(`https://db.netkeiba.com/horse/${horseId}`, '_blank'); 
    };

    const startDrag = (el, x, y) => {
      if (state.viewMode !== 'my') return;
      if (isMultiTouch || isMoving) return;

      isDragging = true;
      document.body.classList.add("is-dragging"); 
      
      dragEl = el;
      if (pointerId && dragEl.setPointerCapture) {
        try { dragEl.setPointerCapture(pointerId); } catch(e){}
      }
      
      dragEl.classList.add("is-placeholder");
      currentIndex = Number(dragEl.dataset.index);
      
      ghostEl = el.cloneNode(true);
      ghostEl.className = "ghost";
      ghostEl.classList.remove("is-placeholder", "pressed");
      const rect = el.getBoundingClientRect();
      ghostEl.style.width = rect.width + "px";
      ghostEl.style.height = rect.height + "px";
      document.body.appendChild(ghostEl);
      updateGhost(x, y);
      
      if (navigator.vibrate) navigator.vibrate(50);
    };

    const updateGhost = (x, y) => {
      if (ghostEl) {
        ghostEl.style.left = x + "px";
        ghostEl.style.top = y + "px";
      }
    };

    this.board.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;
      if (isMultiTouch) return;
      
      if (e.target.closest('.mini-check')) return;

      const cell = e.target.closest(".cell");
      if (!cell || cell.dataset.type !== 'card') return; 

      pointerId = e.pointerId;
      startX = e.clientX; startY = e.clientY;
      isMoving = false;
      cell.classList.add("pressed");

      dragTimer = setTimeout(() => {
        if (!isMoving) startDrag(cell, e.clientX, e.clientY);
      }, CONFIG.longPressDelay);
    });

    this.board.addEventListener("pointermove", (e) => {
      if (e.pointerId !== pointerId) return;

      if (isDragging) {
        e.preventDefault(); 
        updateGhost(e.clientX, e.clientY);
        handleSwapLogic(e.clientX, e.clientY);
        return;
      }

      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      if (dx > CONFIG.moveThreshold || dy > CONFIG.moveThreshold) { 
        isMoving = true;
        if (dragTimer) clearTimeout(dragTimer);
        const cell = e.target.closest(".cell");
        if (cell) cell.classList.remove("pressed");
      }
    });

    this.viewport.addEventListener("touchmove", (e) => {
      if (isDragging) e.preventDefault();
    }, { passive: false });

    const handleSwapLogic = (x, y) => {
      if (ghostEl) ghostEl.style.display = 'none';
      let target = document.elementFromPoint(x, y);
      if (ghostEl) ghostEl.style.display = 'block';

      if (!target) return;
      const targetCell = target.closest('.cell');
      
      if (targetCell && targetCell !== dragEl && this.board.contains(targetCell) && targetCell.dataset.type === 'card') {
        const targetIndex = Number(targetCell.dataset.index);
        
        const fromId = dragEl.dataset.horseId;
        const toId = targetCell.dataset.horseId;
        
        const fromIdxState = state.mySelectionIds.indexOf(fromId);
        const toIdxState = state.mySelectionIds.indexOf(toId);
        
        if (fromIdxState >= 0 && toIdxState >= 0) {
            const temp = state.mySelectionIds[fromIdxState];
            state.mySelectionIds[fromIdxState] = state.mySelectionIds[toIdxState];
            state.mySelectionIds[toIdxState] = temp;
            
            const tempItem = state.renderItems[currentIndex];
            state.renderItems[currentIndex] = state.renderItems[targetIndex];
            state.renderItems[targetIndex] = tempItem;

            const dragHtml = dragEl.innerHTML;
            const dragIdAttr = dragEl.dataset.horseId;
            
            dragEl.innerHTML = targetCell.innerHTML;
            dragEl.dataset.horseId = targetCell.dataset.horseId;
            dragEl.classList.remove("is-placeholder"); 

            targetCell.innerHTML = dragHtml;
            targetCell.dataset.horseId = dragIdAttr;
            targetCell.classList.add("is-placeholder");

            dragEl = targetCell;
            currentIndex = targetIndex;
            if(pointerId) { try{ dragEl.setPointerCapture(pointerId); }catch(e){} }
        }
      }
    };

    const endInteraction = (e) => {
      if (pointerId && e.pointerId !== pointerId) return;
      if (dragTimer) clearTimeout(dragTimer);

      const cell = e.target.closest(".cell");
      
      if (isDragging) {
        isDragging = false;
        document.body.classList.remove("is-dragging");
        if (ghostEl) ghostEl.remove();
        if (dragEl) dragEl.classList.remove("is-placeholder");
        if (cell) cell.classList.remove("pressed");
        this.saveUserState(); 
      } else {
        if (!isMoving && cell && cell.dataset.type === 'card') {
            cell.classList.remove("pressed");
            const now = Date.now();
            if (now - lastTapTime < CONFIG.doubleTapDelay) {
                showDetail(cell);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
      }
      pointerId = null;
    };

    this.board.addEventListener("pointerup", endInteraction);
    this.board.addEventListener("pointercancel", endInteraction);
    
    let initialDist = 0;
    let initialZoom = 1.0;
    this.viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length >= 2) {
        isMultiTouch = true;
        if (isDragging) endInteraction(e); 
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialDist = Math.hypot(dx, dy);
        initialZoom = state.zoom;
        e.preventDefault(); 
      }
    }, { passive: false });

    this.viewport.addEventListener("touchmove", (e) => {
      if (isMultiTouch && e.touches.length >= 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        if (initialDist > 0) {
           const ratio = dist / initialDist;
           const newZoom = Math.min(Math.max(initialZoom * ratio, CONFIG.minZoom), CONFIG.maxZoom);
           state.zoom = newZoom;
           this.updateZoomStyle();
        }
      }
    }, { passive: false });

    this.viewport.addEventListener("touchend", (e) => {
      if (e.touches.length < 2) {
        isMultiTouch = false;
        this.saveUserState();
      }
    });
    
    this.viewport.addEventListener("wheel", (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY * -0.01;
        this.applyZoom(delta);
      }
    }, { passive: false });
  },

  applyZoom(delta) {
    let newZoom = state.zoom + delta;
    newZoom = Math.min(Math.max(newZoom, CONFIG.minZoom), CONFIG.maxZoom);
    state.zoom = newZoom;
    this.updateZoomStyle();
    if (this.zoomTimer) clearTimeout(this.zoomTimer);
    this.zoomTimer = setTimeout(()=> this.saveUserState(), 500);
  }
};

app.init();
</script>
</body>
</html>