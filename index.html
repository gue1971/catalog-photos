<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Horse Board (Grid Map)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  :root {
    --bg: #222;
    --card-bg: #111;
    --text-color: #eee;
    --accent: #0078ff;
    --zoom: 1.0;
    --gap: 2px;
  }

  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Yu Gothic", sans-serif;
    background: var(--bg);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none; /* 全体のスクロールをJSで制御するため */
  }

  .toolbar {
    position: fixed; bottom: 0; left: 0; right: 0;
    height: 48px;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 16px; z-index: 10000;
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  .toolbar-group { display: flex; gap: 16px; align-items: center; }
  .btn {
    background: none; border: 1px solid rgba(255,255,255,0.3);
    color: #ccc; border-radius: 4px; padding: 4px 12px;
    font-size: 12px; cursor: pointer;
  }
  .btn:active { background: rgba(255,255,255,0.2); }
  .zoom-label { font-size: 12px; width: 40px; text-align: center; }

  /* ビューポート */
  .viewport {
    width: 100vw;
    height: calc(100vh - 48px);
    overflow: auto; /* スクロール許可 */
    position: relative;
    -webkit-overflow-scrolling: touch; 
    touch-action: pan-x pan-y pinch-zoom;
  }

  /* ★ グリッドボード (Grid Map)
     ここが今回の肝。FlexboxをやめてCSS Gridにする。
     幅を 100% * zoom にすることで、拡大時に折り返さずにはみ出させる。
  */
  .board {
    display: grid;
    /* 常に12列。1frは「等分」の意味 */
    grid-template-columns: repeat(12, 1fr);
    /* 隙間もズームに合わせて広げる */
    gap: calc(var(--gap) * var(--zoom));
    
    /* 重要: 幅をズーム倍率で決定する。
       1.0なら画面幅ぴったり(100%)。
       2.0なら画面幅の2倍(200%)になり、はみ出した分はスクロールで見る。
    */
    width: calc(100% * var(--zoom));
    
    padding: 8px;
    box-sizing: border-box;
    padding-bottom: 200px; /* 下部の余白 */
    transform-origin: 0 0;
  }

  /* セル */
  .cell {
    position: relative;
    border-radius: calc(2px * var(--zoom));
    overflow: hidden;
    touch-action: pan-x pan-y pinch-zoom;
    /* アスペクト比や高さをCSS Gridで完全に揃える */
    height: auto;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
  }

  .cell.card {
    background: var(--card-bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    border: 1px solid #444;
  }
  
  .cell.card img {
    width: 100%; 
    height: auto;
    display: block; 
    pointer-events: none;
    aspect-ratio: 4/3; 
    object-fit: contain; /* 画像の比率を維持 */
    background: #000;
  }
  
  .cell.card .placeholder-icon {
    width: 100%; 
    aspect-ratio: 4/3;
    background: #000;
    display: flex; align-items: center; justify-content: center;
    color: #555;
    font-size: calc(24px * var(--zoom));
  }

  .cell.card .info-area {
    padding: calc(2px * var(--zoom)) calc(3px * var(--zoom));
    background: var(--card-bg);
    display: block;
    flex-grow: 1; /* 高さを揃えるために伸ばす */
    min-height: calc(14px * var(--zoom)); /* 最低限の高さを確保 */
  }

  .info-title { 
    font-weight: bold;
    font-size: calc(7px * var(--zoom)); 
    margin-bottom: 0;
    color: #eee;
    line-height: 1.1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .info-sub { 
    display: none;
    font-size: calc(6px * var(--zoom));
    color: #999;
    line-height: 1.1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .board.view-detail .cell.card .info-sub { display: block; }

  /* スペーサー（カードと全く同じサイズ・構造にする） */
  .cell.spacer {
    background: rgba(255,255,255,0.03);
    border: 1px dashed rgba(255,255,255,0.1);
  }
  
  /* スペーサーにも透明な比率維持ブロックを入れて高さを強制一致させる */
  .cell.spacer::before {
    content: "";
    display: block;
    width: 100%;
    aspect-ratio: 4/3;
  }
  /* 情報エリア分の高さも確保 */
  .cell.spacer::after {
    content: "";
    display: block;
    flex-grow: 1;
    min-height: calc(14px * var(--zoom));
    border-top: 1px solid rgba(255,255,255,0.05);
  }

  .cell.is-placeholder {
    opacity: 0.15;
    border: 1px dashed #666;
    filter: grayscale(100%);
  }
  
  .cell.pressed {
    transform: scale(0.95);
    transition: transform 0.1s;
    filter: brightness(1.2);
  }

  /* ゴースト */
  .ghost {
    position: fixed; z-index: 9999;
    width: 120px; /* 固定サイズか、計算するか */
    border-radius: 6px; overflow: hidden;
    box-shadow: 0 20px 50px rgba(0,0,0,0.8);
    pointer-events: none;
    background: var(--card-bg);
    border: 1px solid #aaa;
    opacity: 0.95;
    /* ゴーストは少し大きく表示 */
    transform: translate(-50%, -110%) scale(1.1); 
  }
  .ghost img { width: 100%; aspect-ratio: 4/3; display: block; }
  .ghost .info-area { padding: 4px; background: #222; display: block; }
  .ghost .info-title { font-size: 12px; font-weight: bold; color: #fff; }

  body.is-dragging { cursor: grabbing; }
  #fileInput { display: none; }
</style>

</head>
<body>

<div class="viewport" id="viewport">
  <div id="board" class="board"></div>
</div>

<div class="toolbar">
  <div class="toolbar-group">
    <button class="btn" onclick="app.addRow()"><i class="fa-solid fa-plus"></i> 行追加</button>
    <button class="btn" onclick="app.addDummyCard()"><i class="fa-solid fa-horse"></i> 馬追加</button>
  </div>
  <div class="toolbar-group">
    <div class="zoom-label" id="zoomVal">100%</div>
    <button class="btn" onclick="app.resetData()"><i class="fa-solid fa-trash"></i> Reset</button>
    <button class="btn" onclick="app.exportData()"><i class="fa-solid fa-download"></i> JSON</button>
    <button class="btn" onclick="document.getElementById('fileInput').click()"><i class="fa-solid fa-upload"></i></button>
  </div>
</div>

<input type="file" id="fileInput" accept=".json" onchange="app.importData(this)">

<script>
/**
 * Horse Board Logic (v15: Grid Map & Single List)
 * - CSS Gridによる完全なグリッドレイアウト
 * - 拡大時に折り返さず、Mapのように広がる仕様
 * - 常に総数が12の倍数になるようスペーサーを自動管理
 */

const CONFIG = {
  columnCount: 12, // 固定
  minZoom: 1.0,
  maxZoom: 5.0, // 詳細に見るために少し上限アップ
  detailThreshold: 1.5,
  
  longPressDelay: 250, 
  doubleTapDelay: 300,
  
  autoScrollZone: 60,
  autoScrollSpeed: 15,
  
  storageKey: "horse_board_v15_grid" 
};

// 状態管理：2次元配列をやめて1次元配列(items)にする
const state = {
  items: [], 
  zoom: 1.0,
  nextId: 1,
  masterData: [] 
};

function generateUniqueKey() { return `obj_${Date.now()}_${state.nextId++}`; }

const app = {
  async init() {
    this.board = document.getElementById("board");
    this.viewport = document.getElementById("viewport");
    this.zoomVal = document.getElementById("zoomVal");
    
    await this.loadMasterData();
    const hasLocalData = this.loadBoardState();

    if (state.masterData.length > 0) {
       this.syncMasterData(hasLocalData);
    }
    
    // 初期化時にも必ず12の倍数にする
    this.ensureGridCompleteness();

    this.render();
    this.updateZoomStyle();
    this.attachEvents();
  },

  async loadMasterData() {
    try {
      const res = await fetch(`data/horses.json?t=${Date.now()}`);
      if (res.ok) state.masterData = await res.json();
    } catch (e) { state.masterData = []; }
  },

  loadBoardState() {
    const raw = localStorage.getItem(CONFIG.storageKey);
    let loaded = false;
    if (raw) {
      try {
        const saved = JSON.parse(raw);
        // 旧データ(columns配列)からの移行処理
        if (saved.columns && Array.isArray(saved.columns)) {
          state.items = saved.columns.flat(); // 2次元を1次元に平坦化
          loaded = true;
        } else if (saved.items && Array.isArray(saved.items)) {
          state.items = saved.items;
          loaded = true;
        }
        
        state.zoom = Math.max(saved.zoom || 1.0, CONFIG.minZoom);
      } catch(e) { console.error(e); }
    }
    
    // データがない場合、とりあえず1行分(12個)のスペーサーを作る
    if (!loaded || state.items.length === 0) {
      state.items = Array.from({length: CONFIG.columnCount}, () => ({
        uKey: generateUniqueKey(), type: "spacer"
      }));
    }
    return loaded;
  },

  // 常にアイテム総数を12の倍数にする
  ensureGridCompleteness() {
    const remainder = state.items.length % CONFIG.columnCount;
    if (remainder !== 0) {
      const needed = CONFIG.columnCount - remainder;
      for (let i = 0; i < needed; i++) {
        state.items.push({ uKey: generateUniqueKey(), type: "spacer" });
      }
    }
  },

  syncMasterData(hasLocalData) {
    const existingIds = new Set();
    state.items.forEach(item => { if (item.type === 'card' && item.id) existingIds.add(item.id); });

    const newItems = [];
    [...state.masterData].reverse().forEach(data => {
      if (!existingIds.has(data.id)) {
        const newItem = this.buildCardData(data);
        if (hasLocalData) newItem.isNew = true;
        newItems.push(newItem);
      }
    });

    if (newItems.length > 0) {
      // 既存リストの先頭に追加するか、末尾に追加するか
      // ユーザーの要望「最下部に追加」に合わせて末尾に追加し、その後整える
      if (!hasLocalData) {
        // 初回は既存スペーサーを消して置き換え
        state.items = newItems;
      } else {
        // 既にデータがある場合は、既存データの「最後の有効なカード」の後ろに追加したいが
        // 単純に末尾(push)で良い。スペーサー埋めは ensureGridCompleteness でやる
        state.items.push(...newItems);
      }
      this.ensureGridCompleteness();
      this.save();
    }
  },

  buildCardData(data) {
    return {
      uKey: generateUniqueKey(),
      type: "card",
      id: data.id,
      name: data.name,
      sire: data.sire,
      detail: data.detail || {},
      isNew: false
    };
  },

  getImagePath(id) { return `assets/images/${id}.jpeg`; },
  getNetkeibaUrl(id) { return `https://db.netkeiba.com/horse/${id}`; },

  save() {
    // 保存時はスペーサーも含めて保存する（盤面の形状を維持するため）
    const dataToSave = {
      items: state.items.map(item => {
        const { isNew, ...rest } = item; 
        return rest;
      }),
      zoom: state.zoom
    };
    localStorage.setItem(CONFIG.storageKey, JSON.stringify(dataToSave));
  },

  render() {
    // 差分更新ではなく全描画（シンプルさを優先）
    this.board.innerHTML = "";
    
    // Gridアイテムを生成
    state.items.forEach((item, index) => {
      const cell = this.createCell(item, index);
      this.board.appendChild(cell);
    });
  },

  createCell(item, index) {
    const el = document.createElement("div");
    el.className = `cell ${item.type}`;
    if (item.isNew) el.classList.add("new-entry");

    // 1次元配列のインデックスを持たせる
    el.dataset.index = index;
    el.dataset.uKey = item.uKey;
    el.dataset.type = item.type;

    if (item.type === "card") {
      const imgPath = this.getImagePath(item.id);
      el.innerHTML = `
        <img src="${imgPath}" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
        <div class="placeholder-icon" style="display:none"><i class="fa-solid fa-horse-head"></i></div>
        <div class="info-area">
          <div class="info-title">${item.name}</div>
          <div class="info-sub">父: ${item.sire}</div>
        </div>
      `;
      el.dataset.horseId = item.id;
    }
    return el;
  },

  updateZoomStyle() {
    // CSS変数 --zoom を更新。
    // .board の width: calc(100% * var(--zoom)) により、
    // 親(viewport)に対して拡大し、親からはみ出る＝スクロール可能になる
    document.documentElement.style.setProperty('--zoom', state.zoom);
    this.zoomVal.textContent = Math.round(state.zoom * 100) + "%";
    
    if (state.zoom > CONFIG.detailThreshold) {
      this.board.classList.add("view-detail");
    } else {
      this.board.classList.remove("view-detail");
    }
  },

  // 行（12個のスペーサー）を追加
  addRow() {
    for(let i=0; i<CONFIG.columnCount; i++){
      state.items.push({ uKey: generateUniqueKey(), type: "spacer" });
    }
    this.render();
    this.save();
    // 最下部へスクロール
    setTimeout(() => {
        this.viewport.scrollTop = this.viewport.scrollHeight;
    }, 50);
  },
  
  // ダミーカード追加
  addDummyCard() {
    if (state.masterData.length === 0) return;
    const randomData = state.masterData[Math.floor(Math.random()*state.masterData.length)];
    const newItem = this.buildCardData(randomData);
    
    // 末尾に追加して、整合性を取る
    state.items.push(newItem);
    this.ensureGridCompleteness();
    
    this.render();
    this.save();
    
    setTimeout(() => {
        this.viewport.scrollTop = this.viewport.scrollHeight;
    }, 50);
  },

  resetData() {
    if(!confirm("リセットしますか？")) return;
    localStorage.removeItem(CONFIG.storageKey);
    location.reload();
  },
  
  exportData() {
    const str = JSON.stringify({ items: state.items }, null, 2);
    const blob = new Blob([str], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `horse_board_grid.json`;
    a.click();
    URL.revokeObjectURL(url);
  },
  
  importData(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        if (json.items) {
          state.items = json.items;
          this.ensureGridCompleteness();
          this.render();
          this.save();
          alert("インポート完了");
        } else if (json.columns) {
            // 旧形式も受け入れる
            state.items = json.columns.flat();
            this.ensureGridCompleteness();
            this.render();
            this.save();
            alert("インポート完了（旧形式を変換）");
        }
      } catch(err) { alert("エラー"); }
    };
    reader.readAsText(file);
    input.value = "";
  },

  // ------------------------------------------------
  // Events
  // ------------------------------------------------
  attachEvents() {
    let pointerId = null;
    let startX=0, startY=0;
    let dragTimer = null;
    let lastTapTime = 0;
    
    let isDragging = false;
    let isMultiTouch = false;
    
    let dragEl = null;     
    let ghostEl = null;    
    let currentIndex = -1; // 1次元インデックス

    let autoScrollRafId = null;

    // --- PC Zoom ---
    window.addEventListener("keydown", (e) => {
      if (e.target.tagName === 'INPUT') return;
      if (e.key === "+" || e.key === "=") { this.applyZoom(0.1); e.preventDefault(); }
      else if (e.key === "-") { this.applyZoom(-0.1); e.preventDefault(); }
      else if (e.key === "0") { state.zoom = 1.0; this.updateZoomStyle(); this.save(); e.preventDefault(); }
    });

    const clearTimers = () => {
      if (dragTimer) clearTimeout(dragTimer);
      dragTimer = null;
    };

    const showDetail = (el) => {
      el.classList.add("pressed");
      setTimeout(()=> el.classList.remove("pressed"), 200);
      const horseId = el.dataset.horseId;
      if (horseId) window.open(this.getNetkeibaUrl(horseId), '_blank'); 
    };

    // --- Auto Scroll ---
    const stopAutoScroll = () => {
      if (autoScrollRafId) { cancelAnimationFrame(autoScrollRafId); autoScrollRafId = null; }
    };

    const checkAutoScroll = (y) => {
      stopAutoScroll();
      if (!isDragging) return;

      const vHeight = this.viewport.clientHeight;
      const rect = this.viewport.getBoundingClientRect();
      const relativeY = y - rect.top;

      let scrollSpeed = 0;
      if (relativeY < CONFIG.autoScrollZone) {
        scrollSpeed = -CONFIG.autoScrollSpeed * (1 - relativeY / CONFIG.autoScrollZone);
      } else if (relativeY > vHeight - CONFIG.autoScrollZone) {
        scrollSpeed = CONFIG.autoScrollSpeed * (1 - (vHeight - relativeY) / CONFIG.autoScrollZone);
      }

      if (scrollSpeed !== 0) {
        const loop = () => {
          this.viewport.scrollTop += scrollSpeed;
          autoScrollRafId = requestAnimationFrame(loop);
        };
        loop();
      }
    };

    // --- Drag Start ---
    const startDrag = (el, x, y) => {
      if (isMultiTouch) return;

      isDragging = true;
      document.body.classList.add("is-dragging");
      
      dragEl = el;
      // Set Capture (PC/Touch)
      if (pointerId && dragEl.setPointerCapture) {
        try { dragEl.setPointerCapture(pointerId); } catch(e){}
      }
      
      dragEl.classList.add("is-placeholder");
      currentIndex = Number(dragEl.dataset.index);
      
      // ゴースト作成
      ghostEl = el.cloneNode(true);
      ghostEl.className = "ghost";
      ghostEl.classList.remove("is-placeholder", "pressed");
      
      // ゴーストのサイズを計算して合わせる (Gridなのでセル幅を取得)
      const rect = el.getBoundingClientRect();
      ghostEl.style.width = rect.width + "px";
      ghostEl.style.height = rect.height + "px";
      
      document.body.appendChild(ghostEl);
      updateGhost(x, y);
      
      if (navigator.vibrate) navigator.vibrate(50);
    };

    const updateGhost = (x, y) => {
      if (ghostEl) {
        ghostEl.style.left = x + "px";
        ghostEl.style.top = y + "px";
      }
    };

    // --- Pointer Events ---
    this.board.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;
      if (isMultiTouch) return;

      const cell = e.target.closest(".cell");
      if (!cell) return;

      pointerId = e.pointerId;
      startX = e.clientX; 
      startY = e.clientY;
      cell.classList.add("pressed");

      const now = Date.now();
      if (now - lastTapTime < CONFIG.doubleTapDelay) {
        clearTimers();
        showDetail(cell);
        lastTapTime = 0;
        return;
      }
      lastTapTime = now;

      dragTimer = setTimeout(() => {
        startDrag(cell, e.clientX, e.clientY);
      }, CONFIG.longPressDelay);
    });

    this.board.addEventListener("pointermove", (e) => {
      if (e.pointerId !== pointerId) return;

      if (isDragging) {
        e.preventDefault(); 
        checkAutoScroll(e.clientY);
        updateGhost(e.clientX, e.clientY);
        handleSwapLogic(e.clientX, e.clientY);
        return;
      }

      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      if (dx > 8 || dy > 8) { 
        clearTimers();
        const cell = e.target.closest(".cell");
        if (cell) cell.classList.remove("pressed");
      }
    });

    // iPad Scroll Block
    this.viewport.addEventListener("touchmove", (e) => {
      if (isDragging) e.preventDefault();
    }, { passive: false });

    // --- Swap Logic (1D Array) ---
    const handleSwapLogic = (x, y) => {
      // ゴーストを一時的に消して下の要素を取得
      if (ghostEl) ghostEl.style.display = 'none';
      let target = document.elementFromPoint(x, y);
      if (ghostEl) ghostEl.style.display = 'block'; // Gridなのでdisplay:flex/block関係ないがblockで戻す

      if (!target) return;
      const targetCell = target.closest('.cell');
      
      if (targetCell && targetCell !== dragEl && this.board.contains(targetCell)) {
        
        const targetIndex = Number(targetCell.dataset.index);
        
        // データ入れ替え (Swap)
        const temp = state.items[currentIndex];
        state.items[currentIndex] = state.items[targetIndex];
        state.items[targetIndex] = temp;

        // DOM入れ替え
        // Gridの順序はDOMの順序に依存する
        const parent = this.board;
        const items = Array.from(parent.children);
        
        // DOM再構築は重いので、insertBeforeで移動させる
        // targetがcurrentより後ろにあるか前にあるかで挙動が変わるが
        // 単純に「targetの場所にcurrentを持っていく、currentの場所にtargetを持っていく」
        
        // 今回はシンプルにデータ配列に合わせて再描画（数が多いと重いが100件程度なら一瞬）
        // または、要素のdataset.indexを書き換えて中身(HTML)を入れ替える
        
        // ★ 軽量化のため中身交換アプローチを採用
        const dragHtml = dragEl.innerHTML;
        const dragClass = dragEl.className;
        const dragId = dragEl.dataset.horseId;
        const dragKey = dragEl.dataset.uKey;
        const dragType = dragEl.dataset.type;
        
        dragEl.innerHTML = targetCell.innerHTML;
        dragEl.className = targetCell.className;
        dragEl.dataset.horseId = targetCell.dataset.horseId || "";
        dragEl.dataset.uKey = targetCell.dataset.uKey;
        dragEl.dataset.type = targetCell.dataset.type;
        // targetCellはdrag中状態にする
        dragEl.classList.remove("is-placeholder"); 

        targetCell.innerHTML = dragHtml;
        targetCell.className = dragClass;
        targetCell.dataset.horseId = dragId || "";
        targetCell.dataset.uKey = dragKey;
        targetCell.dataset.type = dragType;
        targetCell.classList.add("is-placeholder");

        // 参照を更新
        dragEl = targetCell;
        currentIndex = targetIndex;
        
        if(pointerId) { try{ dragEl.setPointerCapture(pointerId); }catch(e){} }
      }
    };

    const endInteraction = (e) => {
      if (pointerId && e.pointerId !== pointerId) return;
      
      clearTimers();
      stopAutoScroll();

      const cell = e.target.closest(".cell");
      if (cell) cell.classList.remove("pressed");
      
      if (isDragging) {
        isDragging = false;
        document.body.classList.remove("is-dragging");
        
        if (ghostEl) ghostEl.remove();
        if (dragEl) {
          dragEl.classList.remove("is-placeholder");
          if (dragEl.releasePointerCapture && pointerId) {
             try { dragEl.releasePointerCapture(pointerId); } catch(e){}
          }
        }
        this.save();
      }
      pointerId = null;
    };

    this.board.addEventListener("pointerup", endInteraction);
    this.board.addEventListener("pointercancel", endInteraction);
    
    // --- Touch (Pinch Zoom) ---
    let initialDist = 0;
    let initialZoom = 1.0;

    this.viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length >= 2) {
        isMultiTouch = true;
        if (isDragging) {
           isDragging = false;
           document.body.classList.remove("is-dragging");
           if(ghostEl) ghostEl.remove();
           if(dragEl) dragEl.classList.remove("is-placeholder");
           stopAutoScroll();
        }
        clearTimers();
        
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        initialDist = Math.hypot(dx, dy);
        initialZoom = state.zoom;
        e.preventDefault(); 
      }
    }, { passive: false });

    this.viewport.addEventListener("touchmove", (e) => {
      if (isMultiTouch && e.touches.length >= 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        
        if (initialDist > 0) {
           const ratio = dist / initialDist;
           const newZoom = Math.min(Math.max(initialZoom * ratio, CONFIG.minZoom), CONFIG.maxZoom);
           state.zoom = newZoom;
           this.updateZoomStyle();
        }
      }
    }, { passive: false });

    this.viewport.addEventListener("touchend", (e) => {
      if (e.touches.length < 2) {
        isMultiTouch = false;
        this.save();
      }
    });
    
    this.viewport.addEventListener("wheel", (e) => {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = e.deltaY * -0.01;
        this.applyZoom(delta);
      }
    }, { passive: false });
  },

  applyZoom(delta) {
    let newZoom = state.zoom + delta;
    newZoom = Math.min(Math.max(newZoom, CONFIG.minZoom), CONFIG.maxZoom);
    state.zoom = newZoom;
    this.updateZoomStyle();
    if (this.zoomTimer) clearTimeout(this.zoomTimer);
    this.zoomTimer = setTimeout(()=> this.save(), 500);
  }
};

app.init();
</script>
</body>
</html>